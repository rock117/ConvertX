// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ConvertProgress`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`

/// 检测文件类型
Future<FileType?> detectFileType({required String filePath}) =>
    RustLib.instance.api.crateApiDetectFileType(filePath: filePath);

/// 获取支持的输出格式
Future<List<String>> getSupportedOutputFormats({required FileType fileType}) =>
    RustLib.instance.api.crateApiGetSupportedOutputFormats(fileType: fileType);

/// 获取某个具体文件（根据扩展名/类型）实际支持的输出格式
///
/// 注意：这会比 `get_supported_output_formats(FileType)` 更严格，避免 UI 展示无效选项。
Future<List<String>> getSupportedOutputFormatsForFile(
        {required String filePath}) =>
    RustLib.instance.api
        .crateApiGetSupportedOutputFormatsForFile(filePath: filePath);

/// 转换单个文件
Future<ConvertResult> convertFile(
        {required String inputPath,
        required String outputDir,
        required ConvertOptions options}) =>
    RustLib.instance.api.crateApiConvertFile(
        inputPath: inputPath, outputDir: outputDir, options: options);

/// 批量转换文件
Future<List<ConvertResult>> convertFiles(
        {required List<String> inputPaths,
        required String outputDir,
        required ConvertOptions options}) =>
    RustLib.instance.api.crateApiConvertFiles(
        inputPaths: inputPaths, outputDir: outputDir, options: options);

/// 打开文件夹
Future<bool> openFolder({required String folderPath}) =>
    RustLib.instance.api.crateApiOpenFolder(folderPath: folderPath);

/// 转换选项
class ConvertOptions {
  /// 输出格式 (如 "png", "jpg", "pdf", "mp4")
  final String outputFormat;

  /// 图片质量 (1-100, 用于 JPEG/WebP 压缩)
  final int? imageQuality;

  /// 音频质量 (MP3/OGG: 0-9, 越低越好; 或 AAC 的比特率如 192)
  final int? audioQuality;

  /// 音频比特率 kbps (如 128, 192, 320) - audioQuality 的替代选项
  final int? audioBitrate;

  /// 音频采样率 Hz (如 44100, 48000)
  final int? audioSampleRate;

  /// 视频 CRF 质量 (0-51, 越低越好, H.264 默认 23)
  final int? videoCrf;

  /// 视频比特率 kbps (如 2000, 5000) - videoCrf 的替代选项
  final int? videoBitrate;

  /// 视频宽度 (用于调整尺寸)
  final int? videoWidth;

  /// 视频高度 (用于调整尺寸)
  final int? videoHeight;

  /// FFmpeg 执行文件路径（如果由 Dart 端下载提供）
  final String? ffmpegPath;

  const ConvertOptions({
    required this.outputFormat,
    this.imageQuality,
    this.audioQuality,
    this.audioBitrate,
    this.audioSampleRate,
    this.videoCrf,
    this.videoBitrate,
    this.videoWidth,
    this.videoHeight,
    this.ffmpegPath,
  });

  @override
  int get hashCode =>
      outputFormat.hashCode ^
      imageQuality.hashCode ^
      audioQuality.hashCode ^
      audioBitrate.hashCode ^
      audioSampleRate.hashCode ^
      videoCrf.hashCode ^
      videoBitrate.hashCode ^
      videoWidth.hashCode ^
      videoHeight.hashCode ^
      ffmpegPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConvertOptions &&
          runtimeType == other.runtimeType &&
          outputFormat == other.outputFormat &&
          imageQuality == other.imageQuality &&
          audioQuality == other.audioQuality &&
          audioBitrate == other.audioBitrate &&
          audioSampleRate == other.audioSampleRate &&
          videoCrf == other.videoCrf &&
          videoBitrate == other.videoBitrate &&
          videoWidth == other.videoWidth &&
          videoHeight == other.videoHeight &&
          ffmpegPath == other.ffmpegPath;
}

/// 转换结果
class ConvertResult {
  /// 是否成功
  final bool success;

  /// 输出文件路径
  final String? outputPath;

  /// 错误信息
  final String? error;

  const ConvertResult({
    required this.success,
    this.outputPath,
    this.error,
  });

  @override
  int get hashCode => success.hashCode ^ outputPath.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConvertResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          outputPath == other.outputPath &&
          error == other.error;
}

/// 文件类型枚举
enum FileType {
  image,
  document,
  audio,
  video,
  ;
}
